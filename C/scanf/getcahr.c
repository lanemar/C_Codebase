/*
	2020.12.18
	char类型输入读取跳过解决方法。 
*/

#include <stdio.h>

int main(void){
	int a;
	char b; 
	scanf("%d",&a);//%d会跳过非整型参数的字符 
	//getchar();//这里需要getchar()来跳过\n，但只能跳过一次。 
	//getchar();// 
	while((b=getchar())!= '\n')
		continue;//跳出当前函数 
	//当缓冲区不为空时跳过已被占用的缓存区，直到缓存为空跳出while循环。 
	scanf("%c",&b);//%c会读取任意的一个字符 
	printf("%d,%c",a,b);
	
	/*
	
	int i;
	char ch;
	scanf("%d",&i);//输入123m 
	printf("%d\n",i);//输入123 
	scanf("%c",&ch);//跳过 
	printf("%c",ch);//输出m 
	
	*/
	
	return 0;
}

/*
-----------------------------
未使用getchar函数时输入a后回车会直接跳过b。 
输入：1
输出：1 

使用getchar()语句：
 输入：1,2
 输出：1,2 
 
使用getchar()语句：
输入：a=123m 回车
输出：123， 
----------------------------- 

在连续进行scanf输入时： 
如果只使用getchar()语句对\n进行跳过，那么在用户在上一个参数输入出现错误时，类型错误的值会被系统丢弃，
其后面的\n则不会被丢弃，所以单句getchar语句只跳过了一个\n，而b会读取到下一个\n。 
这个程序如果使用两条getchar()语句进行跳过\n可以实现对b进行输入，但还是推荐使用循环跳过不会空的缓冲区。
另一种情况：不连续的scanf输入：
一般在第一个参数输入时，比如使用%d输入与输出，那么系统会自动判断缓冲区中从键盘读取到的字符是否为整型数值。
是则读取该值，直到读取到非整型数值则结束读取，并将读取到的整型数值赋值给指定的变量。 
下一个scanf读取缓存区时，会直接从之前结束的地方开始读取。 
*/ 
